#!/bin/perl
#Author: ALin
#Purpose: To check transcripts in a .gtf file using a .gff file, generated by alingining external transcripts to the reference genome using GMAP. The output is a table indicating the corresponding relationships of transcripts.
#Usage: perl NIAP_compare_v1.1.pl [option]
#		-query <String> Input .gtf file to be checked
#		-ref <String> Input .gff file of external transcripts
#		-o <String> Output file
#		-s <Boolean> Strand-specific query. (Default: Non-strand-specific)
#		-btp <String> Path for bedtools
#		-h <Boolean> Help
#Change logs:
#	v1.1	This script was adopted from annotate_gtf_v1.2.pl. 

use strict;
use Getopt::Long;
use List::Util qw(min max sum);

my $ref = "";
my $query = "";
my $out = "";
my $stranded = 0;
my $btp;
my $help = 0;



GetOptions(
	'query=s'	=>	\$query,
	'ref=s'	=>	\$ref,
        'o=s'   =>      \$out,
	's!'	=>	\$stranded,
	'btp'	=>	\$btp,
	'h!'    =>      \$help,
);

unless($btp){
	$btp = "bedtools";
}

unless(`$btp`){
	print "Incorrect path for bedtools!\n";
	print_usage();
	exit;
}

if($help){
        print_usage();
        exit;
}

unless($query && $ref && $out){
	print_usage();
	exit;
}

system("bedtools sort -i $query >  temp_query_sorted.gtf");
system("bedtools sort -i $ref >  temp_ref_sorted.gff");
open(QUERY, "temp_query_sorted.gtf") or die "Cannot open $query!\n";
open(REF, "temp_ref_sorted.gff") or die "Cannot open $ref!\n";
open(OUT, ">$out") or die "Cannot create $out!\n";

my %ref_transcript = ();
my %query_transcript = ();
my %ref_gene = ();
my %query_gene = ();

#Load reference annotation
while(<REF>){
	chomp;
	my $line = $_;
	my @line = split('\t', $line);
	unless($line[2] eq "exon"){
		next;
	}
	$line[8] =~ /Parent=([^\;]+)\;/;
	my $transcript_id = $1;
	$line[8] =~ /Name=([^\;]+)\;/;
	my $gene_id = $1;
	unless(exists $ref_transcript{$transcript_id}){
		%{$ref_transcript{$transcript_id}} = ();
		$ref_transcript{$transcript_id}{'gene'} = $gene_id;
		$ref_transcript{$transcript_id}{'chr'} = $line[0];
		$ref_transcript{$transcript_id}{'source'} = $line[1];
		$ref_transcript{$transcript_id}{'left'} = $line[3];
		$ref_transcript{$transcript_id}{'right'} = $line[4];
		$ref_transcript{$transcript_id}{'strand'} = $line[6];
		@{$ref_transcript{$transcript_id}{'exon'}} = ();
	}
	my @exon = ($line[3], $line[4]);
	push(@{$ref_transcript{$transcript_id}{'exon'}}, \@exon);
	unless(exists $ref_gene{$gene_id}){
		%{$ref_gene{$gene_id}} = ();
		$ref_gene{$gene_id}{'chr'} = $line[0];
		$ref_gene{$gene_id}{'source'} = $line[1];
		$ref_gene{$gene_id}{'left'} = $line[3];
		$ref_gene{$gene_id}{'right'} = $line[4];
		$ref_gene{$gene_id}{'strand'} = $line[6];
	}
	if(($ref_gene{$gene_id}{'strand'} eq "\.") && ($line[6] ne "\.")){
		$ref_gene{$gene_id}{'strand'} = $line[6];
	}
	if($ref_gene{$gene_id}{'left'} > $line[3]){
		$ref_gene{$gene_id}{'left'} = $line[3];
	}
	if($ref_gene{$gene_id}{'right'} < $line[4]){
		$ref_gene{$gene_id}{'right'} = $line[4];
	}
}
close REF;

#Load query annotation
while(<QUERY>){
	chomp;
	my $line = $_;
	my @line = split('\t', $line);
	unless($line[2] eq "exon"){
		next;
	}
	$line[8] =~ /transcript_id \"([^\"]+)\"/;
	my $transcript_id = $1;
	$line[8] =~ /gene_id \"([^\"]+)\"/;
	my $gene_id = $1;
	unless(exists $query_transcript{$transcript_id}){
		%{$query_transcript{$transcript_id}} = ();
		$query_transcript{$transcript_id}{'gene'} = $gene_id;
		$query_transcript{$transcript_id}{'chr'} = $line[0];
		$query_transcript{$transcript_id}{'source'} = $line[1];
		$query_transcript{$transcript_id}{'left'} = $line[3];
		$query_transcript{$transcript_id}{'right'} = $line[4];
		$query_transcript{$transcript_id}{'strand'} = $line[6];
		@{$query_transcript{$transcript_id}{'exon'}} = ();
	}
	my @exon = ($line[3], $line[4]);
	push(@{$query_transcript{$transcript_id}{'exon'}}, \@exon);
	unless(exists $query_gene{$gene_id}){
		%{$query_gene{$gene_id}} = ();
		$query_gene{$gene_id}{'chr'} = $line[0];
		$query_gene{$gene_id}{'source'} = $line[1];
		$query_gene{$gene_id}{'left'} = $line[3];
		$query_gene{$gene_id}{'right'} = $line[4];
		$query_gene{$gene_id}{'strand'} = $line[6];
	}
	if(($query_gene{$gene_id}{'strand'} eq "\.") && ($line[6] ne "\.")){
		$query_gene{$gene_id}{'strand'} = $line[6];
	}
	if($query_gene{$gene_id}{'left'} > $line[3]){
		$query_gene{$gene_id}{'left'} = $line[3];
	}
	if($query_gene{$gene_id}{'right'} < $line[4]){
		$query_gene{$gene_id}{'right'} = $line[4];
	}
}
close QUERY;

#Map query transcirpts to reference
my %map = ();

open(IN, "bedtools intersect -wao -nonamecheck -a temp_query_sorted.gtf -b temp_ref_sorted.gff |");

while(<IN>){
	chomp;
	my $line = $_;
	my @line = split('\t', $line);
	if(($line[2] ne "exon") || ($line[11] ne "exon")){
		next;
	}
	
	$line[8] =~ /transcript_id \"([^\"]+)\"/;
	my $query_transcript_id = $1;
	my $query_exon_num = @{$query_transcript{$query_transcript_id}{'exon'}};
	#If non-strand-specific, force all query transcripts with single exon to be with no strand information.
	if(($stranded == 0) && ($query_exon_num == 1) && ($line[6] ne "\.")){
		$line[6] = "\.";
		$query_transcript{$query_transcript_id}{'strand'} = "\.";
	}
	#Get reference transcript name
	#Amendment is needed for alternative reference annotation.
	$line[17] =~ /Parent=([^\;]+)\;/;
	my $ref_transcript_id = $1;
	my $ref_exon_num = @{$ref_transcript{$ref_transcript_id}{'exon'}};
	#Check whether the query is really strand-specific
	if(($stranded == 1) && ($query_transcript{$query_transcript_id}{'strand'} eq "\.")){
		print "$query_transcript_id is non-strand-specific!\n";
		#exit;
	}
	#Check whether strands match
	if($stranded == 0){
		#Stranded disable
		if(($line[6] ne $line[15]) && ($line[6] ne "\.")){
			#Wrong strand
			next;
		}
	}
	else{
		#Stranded enable
		if($line[6] ne $line[15]){
			#Wrong strand
			next;
		}
	}
	#Mapping query transcript to reference
	unless(exists $map{$query_transcript_id}){
		%{$map{$query_transcript_id}} = ();
	}
	unless(exists $map{$query_transcript_id}{$ref_transcript_id}){
		%{$map{$query_transcript_id}{$ref_transcript_id}} = ();
		@{$map{$query_transcript_id}{$ref_transcript_id}{'query'}} = (0) x $query_exon_num;
		@{$map{$query_transcript_id}{$ref_transcript_id}{'ref'}} = (0) x $ref_exon_num;
	}
	#Get the exon number of the current query exon
	my $cur_query_exon_num;
	SEARCH:for(my $i = 0; $i < $query_exon_num; $i++){
		my $hit_flag = 0;
		if($query_exon_num == 1){
			$hit_flag = 1;
		}
		elsif($i == 0){
			if($query_transcript{$query_transcript_id}{'exon'}[$i][1] == $line[4]){
				$hit_flag = 1;
			}
		}
		elsif($i == ($query_exon_num - 1)){
			if($query_transcript{$query_transcript_id}{'exon'}[$i][0] == $line[3]){
				$hit_flag = 1;
			}
		}
		elsif(($query_transcript{$query_transcript_id}{'exon'}[$i][0] == $line[3]) && ($query_transcript{$query_transcript_id}{'exon'}[$i][1] == $line[4])){
			$hit_flag = 1;
		}
		if($hit_flag == 1){
			if($line[6] eq "-"){
				$cur_query_exon_num = $query_exon_num - $i;
			}
			else{
				$cur_query_exon_num = $i + 1;
			}
			last SEARCH;
		}
	}
	#Get the exon number of the current reference exon
	my $cur_ref_exon_num;
	SEARCH:for(my $i = 0; $i < $ref_exon_num; $i++){
		my $hit_flag = 0;
		if($ref_exon_num == 1){
			$hit_flag = 1;
		}
		elsif($i == 0){
			if($ref_transcript{$ref_transcript_id}{'exon'}[$i][1] == $line[13]){
				$hit_flag = 1;
			}
		}
		elsif($i == ($ref_exon_num - 1)){
			if($ref_transcript{$ref_transcript_id}{'exon'}[$i][0] == $line[12]){
				$hit_flag = 1;
			}
		}
		elsif(($ref_transcript{$ref_transcript_id}{'exon'}[$i][0] == $line[12]) && ($ref_transcript{$ref_transcript_id}{'exon'}[$i][1] == $line[13])){
			$hit_flag = 1;
		}
		if($hit_flag == 1){
			if($line[15] eq "-"){
				$cur_ref_exon_num = $ref_exon_num - $i;
			}
			else{
				$cur_ref_exon_num = $i + 1;
			}
			last SEARCH;
		}
	}
	my $match = 0;
	if(($ref_exon_num == 1) && ($query_exon_num == 1)){
		#Both query and reference transcripts are monoexonic.
		$match = 1;
	}
	elsif(($ref_exon_num > 1) && ($query_exon_num > 1)){
		#Both query and reference transcripts are multiexonic.
		if(($cur_query_exon_num == 1) || ($cur_ref_exon_num == 1)){
			if($line[6] eq "\-"){
				#The rightmost case
				if($line[3] == $line[12]){
					$match = 1;
				}
			}
			else{
				#The leftmost case
				if($line[4] == $line[13]){
					$match = 1;
				}
			}
		}
		elsif(($cur_query_exon_num == $query_exon_num) || ($cur_ref_exon_num == $ref_exon_num)){
			if($line[6] eq "\-"){
				#The leftmost case
				if($line[4] == $line[13]){
					$match = 1;
				}
			}
			else{
				#The rightmost case
				if($line[3] == $line[12]){
					$match = 1;
				}
			}
		}
		else{
			#Internal exon
			if(($line[3] == $line[12]) && ($line[4] == $line[13])){
				#Matching both exon ends
				$match = 1;
			}
		}
	}
	if($match == 1){
		if($line[6] eq "\-"){
			$map{$query_transcript_id}{$ref_transcript_id}{'query'}[($query_exon_num - $cur_query_exon_num)] = 1;
			$map{$query_transcript_id}{$ref_transcript_id}{'ref'}[($ref_exon_num - $cur_ref_exon_num)] = 1;
		}
		else{
			$map{$query_transcript_id}{$ref_transcript_id}{'query'}[($cur_query_exon_num - 1)] = 1;
			$map{$query_transcript_id}{$ref_transcript_id}{'ref'}[($cur_ref_exon_num - 1)] = 1;
		}
	}
}
close IN;
system("rm temp_ref_sorted.gff");
system("rm temp_query_sorted.gtf");

#Evaluate mapping
my %match = ();

foreach my $query_transcript_id (keys %map){
	#Loop through the map and identify the best annotation
	foreach my $ref_transcript_id (keys %{$map{$query_transcript_id}}){	#There may be a bug in this loop such that query transcripts spanning more than one annoatated genes will be assigned to one of the the genes randomly, according to the order in the hash. #But this bug is kind of solved now. #A change of the way to get gene ID.
		my $query_gene_id = $query_transcript{$query_transcript_id}{'gene'};
		my $query_code = join('', @{$map{$query_transcript_id}{$ref_transcript_id}{'query'}});
		my $ref_code = join('', @{$map{$query_transcript_id}{$ref_transcript_id}{'ref'}});
		if(($query_code eq $ref_code) && !($query_code =~ /0/) && !($ref_code =~ /0/)){
			unless(exists $match{$query_gene_id}){
				%{$match{$query_gene_id}} = ();
			}
			unless(exists $match{$query_gene_id}{$query_transcript_id}){
				%{$match{$query_gene_id}{$query_transcript_id}} = ();
			}
			unless(exists $match{$query_gene_id}{$query_transcript_id}{$ref_transcript_id}){
				$match{$query_gene_id}{$query_transcript_id}{$ref_transcript_id} = 1;
			}
		}
	}
}

%map = ();

print OUT "Gene_id\tTranscript_id\tExternal_id";

foreach my $query_gene_id (keys %match){
	foreach my $query_transcript_id (keys %{$match{$query_gene_id}}){
		my $ext_id = join(',', keys %{$match{$query_gene_id}{$query_transcript_id}});
		print OUT "\n$query_gene_id\t$query_transcript_id\t$ext_id";
	}
}
close OUT;


sub print_usage{
	print "Usage: perl NIAP_compare_v1.1.pl [option]\n\t-query <String> Input .gtf file to be checked\n\t-ref <String> Input .gff file of external transcripts\n\t-o <String> Output file\n\t-s <Boolean> Strand-specific query. (Default: Non-strand-specific)\n\t-btp <String> Path for bedtools\n\t-h <Boolean> Help\n";
}





