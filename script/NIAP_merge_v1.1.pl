#!/bin/perl
#Author: ALin
#Purpose: To merge transcripts in gtf files generated by StringTie, or other type of StringTie out like or similar .gtf files, output an expression table, if available, and a table indicating the original IDs.
#Usage: perl NIAP_merge_v1.1.pl [option]
#		-in <String> Input list of StringTie gtf
#		-out <String> Output base
#		-exp <String>  The atribute for the getting expression value (cov, FPKM, TPM and etc.)
#		-btp <String> The path to bedtools
#Change log:
#	v1.1	2021-03	It was descended from merge_StringTie_gtf_v1.2.pl. It now does not only support StringTie output like files, but also .gtf without transcripts rows.

use strict;
use Getopt::Long;
use List::Util qw(max min);

my $in;
my $out;
my $exp;
my $btp;
my $help = 0;

GetOptions(
	'in=s'	=>	\$in,
	'out=s'	=>	\$out,
	'exp=s'	=>	\$exp,
	'btp=s'	=>	\$btp,
        'h!'    =>      \$help,
);

if($help){
        print_usage();
        exit;
}

unless($btp){
	$btp = "bedtools";
}

unless(`which $btp`){
	print "Incorrect path for bedtools!\n";
	print_usage();
	exit;
}

unless($in && $out){
	print_usage();
	exit;
}

my $out_gtf = $out . ".gtf";
my $out_exp = $out . "_exp.txt";
my $out_id = $out . "_id.txt";
my %loci = ();
my @sample = ();
parse_list($in, \%loci);
print_gtf_exp(\%loci, $in, $out, $exp, $btp, $out_gtf, $out_exp, $out_id);

sub print_usage{
	print "Usage: perl NIAP_merge_v1.1.pl [option]\n\t-in <String> Input list of StringTie gtf\n\t-out <String> Output base\n\t-exp <String>  The atribute for the getting expression value (cov, FPKM, TPM or etc.)\n\t-btp <String> The path to bedtools\n";
}

#Count the number of samples
sub count_sample{
	my $temp_in = $_[0];
	my $temp_num_sample = 0;
	open(TEMP, $temp_in) or die "Cannot open $temp_in!\n";
	while(<TEMP>){
		chomp;
		my $temp_line = $_;
		$temp_line =~ s/\r//;
		push(@sample, $temp_line);
		$temp_num_sample++;
	}
	close TEMP;

	return $temp_num_sample;
}

#Parse the list
sub parse_list{
	my $temp_in = $_[0];
	my $loci_ref = $_[1];
	my $temp_num_sample = count_sample($temp_in);
	my $temp_cur_sample = 0;
	open(TEMP, $temp_in) or die "Cannot open $temp_in!\n";
	while(<TEMP>){
		chomp;
		my $temp_line = $_;
		$temp_line =~ s/\r//;
		parse_gtf($temp_line, $temp_num_sample, $temp_cur_sample, $loci_ref);
		#Sort loci
		foreach my $temp_chr (keys %{$loci_ref}){
			foreach my $temp_strand (keys %{$loci_ref->{$temp_chr}}){
				my @temp_merged = merge_loci($temp_num_sample, \@{$loci_ref->{$temp_chr}{$temp_strand}});
				@{$loci_ref->{$temp_chr}{$temp_strand}} = @temp_merged;
				#print "$temp_chr\t$temp_strand\t@{$loci_ref->{$temp_chr}{$temp_strand}}\n";
			}
		}
		#Make an increament of the global sample counter
		$temp_cur_sample++;
	}
	close TEMP;

	return 1;
}

#Parse a gtf file
sub parse_gtf{
	my $temp_gtf = $_[0];
	my $temp_num_sample = $_[1];
	my $temp_cur_sample = $_[2];
	my $loci_ref = $_[3];
	open(GTF, $temp_gtf) or die "Cannot open $temp_gtf!\n";
	my %temp_transcript = ();
	my $temp_exp_flag = 0;
	while(<GTF>){
		chomp;
		my $temp_line = $_;
		$temp_line =~ s/\r//;
		my @temp_line = split('\t', $temp_line);
		$temp_line[8] =~ /transcript_id \"([^\;]+)\"/;
		my $temp_transcript_id = $1;
		if(($temp_line[2] eq "transcript") || ($temp_line[2] eq "exon")){
			my $temp_exp = 0;
			if($temp_line[8] =~ /$exp \"([^\;]+)\"/){
				$temp_exp = $1;
				$temp_exp_flag = 1;
			}
			unless(exists $temp_transcript{$temp_transcript_id}){
				%{$temp_transcript{$temp_transcript_id}} = ();
				$temp_transcript{$temp_transcript_id}{'chr'} = $temp_line[0];
				$temp_transcript{$temp_transcript_id}{'strand'} = $temp_line[6];
				$temp_transcript{$temp_transcript_id}{'exp'} = $temp_exp;
				@{$temp_transcript{$temp_transcript_id}{'exon'}} = ();
			}
			if($temp_line[2] eq "exon"){
				my @temp_exon = ($temp_line[3], $temp_line[4]);
				push(@{$temp_transcript{$temp_transcript_id}{'exon'}}, \@temp_exon);
			}
		}
	}
	close GTF;
	if($temp_exp_flag == 0){
		print "Invalid attribute $exp, no expression data will be output.\n";
	}
	parse_transcript(\%temp_transcript, $temp_num_sample, $temp_cur_sample, $loci_ref);

	return 1;
}

#Parse the transcripts
sub parse_transcript{
	my $temp_transcript_ref = $_[0];
	my $temp_num_sample = $_[1];
	my $temp_cur_sample = $_[2];
	my $loci_ref = $_[3];
	foreach my $temp_transcript (keys %{$temp_transcript_ref}){
		#Extract the information of the current transcript for simplicity
		my $temp_chr = $temp_transcript_ref->{$temp_transcript}{'chr'};
		my $temp_strand = $temp_transcript_ref->{$temp_transcript}{'strand'};
		my $temp_exp = $temp_transcript_ref->{$temp_transcript}{'exp'};
		my @temp_exon = @{$temp_transcript_ref->{$temp_transcript}{'exon'}};
		#Parse the exon structure
		my @temp_sorted_exon = sort {$a->[0]<=>$b->[0]} @temp_exon;
		my $temp_num_exon = @temp_sorted_exon;
		my $temp_exon_chain = $temp_sorted_exon[0][0] . "-" . $temp_sorted_exon[0][1];
		for(my $i = 1; $i < $temp_num_exon; $i++){
			$temp_exon_chain .= "," . $temp_sorted_exon[$i][0] . "-" . $temp_sorted_exon[$i][1];
		}
		my @temp_eej = split('-', $temp_exon_chain);
		my $temp_leftmost = shift @temp_eej;
		my $temp_rightmost = pop @temp_eej;
		my $temp_eej = "-" . join("-", @temp_eej) . "-";
		$temp_eej =~ s/--/-/;
		#print "$temp_chr\t$temp_strand\t$temp_exp\t$temp_exon_chain\n$temp_leftmost\t$temp_rightmost\t$temp_eej\t$temp_transcript\n";
		add_transcript($loci_ref, $temp_num_sample, $temp_cur_sample, $temp_chr, $temp_strand, $temp_exp, $temp_leftmost, $temp_rightmost, $temp_eej, $temp_transcript);
	}

	return 1;
}

#Add a transcript
sub add_transcript{
	my $loci_ref = $_[0];
	my $temp_num_sample = $_[1];
	my $temp_cur_sample = $_[2];
	my $temp_chr = $_[3];
	my $temp_strand = $_[4];
	my $temp_exp = $_[5];
	my $temp_leftmost = $_[6];
	my $temp_rightmost = $_[7];
	my $temp_eej = $_[8];
	my $temp_transcript_id = $_[9];
	#Initiate the chromosome tab
	unless(exists $loci_ref->{$temp_chr}){
		%{$loci_ref->{$temp_chr}} = ();
	}
	#Initiate the strand of the chromosome tab
	unless(exists $loci_ref->{$temp_chr}{$temp_strand}){
		@{$loci_ref->{$temp_chr}{$temp_strand}} = ();
	}
	my @temp_exp = (0) x $temp_num_sample;
	$temp_exp[$temp_cur_sample] = $temp_exp;
	my %temp_transcript = ();
	unless(exists $temp_transcript{$temp_eej}){
		@{$temp_transcript{$temp_eej}} = ();
	}
	my %temp_transcript_id = ();
	unless(exists $temp_transcript_id{$temp_transcript_id}){
		$temp_transcript_id{$temp_transcript_id} = 1;
	}
	my @temp_transcript = ($temp_leftmost, $temp_rightmost, \@temp_exp, \%temp_transcript_id);
	push(@{$temp_transcript{$temp_eej}}, \@temp_transcript);
	my @temp_loci = ($temp_leftmost, $temp_rightmost, \%temp_transcript);
	push(@{$loci_ref->{$temp_chr}{$temp_strand}}, \@temp_loci);
	#print "Loci:@temp_loci\n";
	#foreach my $i (keys %{$temp_loci[2]}){
		#print "\tEEJ:$i\n";
		#foreach my $j (@{$temp_loci[2]{$i}}){
			#print "\tTranscript:@{$j}\n";
			#print "EXP:@{$j->[2]}\n";
		#}
	#}

	return 1;
}

#Sort loci
sub merge_loci{
	my ($temp_num_sample, $temp_sref, $temp_start) = @_;
	return if(ref($temp_sref ne 'ARRAY'));

	if(!defined $temp_start){
		if(wantarray){
			my @temp_sets = map {[@{$_}]} @{$temp_sref};
			$temp_sref = \@temp_sets;
		}
		@{$temp_sref} = sort {$a->[0]<=>$b->[0] || $a->[1]<=>$b->[1]} @{$temp_sref};
		$temp_start = 0;
	}
	my $temp_last = $temp_sref->[$temp_start];
	$temp_start++;

	if(@{$temp_last}){
		for(my $i = $temp_start; $i < @{$temp_sref}; $i++){
			my $temp_cur = $temp_sref->[$i];
			if(!@{$temp_cur}){
				next;
			}

			if($temp_cur->[0] >= $temp_last->[0] && $temp_cur->[0] <= $temp_last->[1]){
				#print "Last:@{$temp_last}\nCur:@{$temp_cur}\n";
				if ($temp_cur->[1] > $temp_last->[1]){
					$temp_last->[1] = $temp_cur->[1];
				}
				
				foreach my $temp_cur_eej (keys %{$temp_cur->[2]}){
					#print "Cur EEJ:$temp_cur_eej\n";
					if(exists $temp_last->[2]{$temp_cur_eej}){
						#print "Exists in last\n";
						push(@{$temp_last->[2]{$temp_cur_eej}}, @{$temp_cur->[2]{$temp_cur_eej}});
						#print "@{$temp_last->[2]{$temp_cur_eej}}\n";
						my @temp_new_transcript = merge_transcript($temp_num_sample, $temp_last->[2]{$temp_cur_eej});
						@{$temp_last->[2]{$temp_cur_eej}} = @temp_new_transcript;
					}
					else{
						#print "Not exist\nAdd:@{$temp_cur->[2]{$temp_cur_eej}}\n";
						foreach my $i (@{$temp_cur->[2]{$temp_cur_eej}}){
							#print "@{$i}\n";
						}
						@{$temp_last->[2]{$temp_cur_eej}} = merge_transcript($temp_num_sample, $temp_cur->[2]{$temp_cur_eej});
						#print "New last EEJ:@{$temp_last->[2]{$temp_cur_eej}->[0]}\n";
					}
				}
				@{$temp_cur} = ();
			}
			else{
				last;
			}
		}
	}
	if($temp_start < @{$temp_sref}){
		merge_loci($temp_num_sample, $temp_sref, $temp_start);
	}
	if(wantarray){
		return sort {$a->[0] <=> $b->[0]} map {@{$_} ? $_ : () } @{$temp_sref};
	}
}

#

#Merge transcripts with the same exon-exon junction in the same locus
sub merge_transcript{
	my ($temp_num_sample, $temp_sref, $temp_start) = @_;
	return if(ref($temp_sref) ne 'ARRAY');
	#print "Merging @{$temp_sref}\n";
	if(!defined $temp_start){
		if(wantarray){
			my @temp_sets = map {[@{$_}]} @{$temp_sref};
			$temp_sref = \@temp_sets;
		}
		@{$temp_sref} = sort {$a->[0]<=>$b->[0] || $a->[1]<=>$b->[1]} @{$temp_sref};
		$temp_start = 0;
	}
	my $temp_last = $temp_sref->[$temp_start];
	$temp_start++;

	if(@{$temp_last}){
		for(my $i = $temp_start; $i < @{$temp_sref}; $i++){
		my $temp_cur = $temp_sref->[$i];
			if(!@{$temp_cur}){
				next;
			}

			if ($temp_cur->[0] >= $temp_last->[0] && $temp_cur->[0] <= $temp_last->[1] ){
				if ($temp_cur->[1] > $temp_last->[1]){
					$temp_last->[1] = $temp_cur->[1];
				}
				my @temp_last_exp = @{$temp_last->[2]};
				my @temp_cur_exp = @{$temp_cur->[2]};
				for($i = 0; $i < $temp_num_sample; $i++){
					$temp_last_exp[$i] += $temp_cur_exp[$i];
				}
				@{$temp_last->[2]} = @temp_last_exp;
				my %temp_last_tid = %{$temp_last->[3]};
				my %temp_cur_tid = %{$temp_cur->[3]};
				foreach my $temp_tid (keys %temp_cur_tid){
					unless(exists $temp_last_tid{$temp_tid}){
						$temp_last_tid{$temp_tid} = 1;
					}
				}
				%{$temp_last->[3]} = %temp_last_tid;
				@{$temp_cur} = ();
			}
			else{
				last;
			}
		}
	}
	if($temp_start < @{$temp_sref}){
		merge_transcript($temp_num_sample, $temp_sref, $temp_start);
	}
	if(wantarray){
		return sort {$a->[0] <=> $b->[0]} map {@{$_} ? $_ : () } @{$temp_sref};
	}
}

#Print the record in gtf format and the expression level
sub print_gtf_exp{
	my $loci_ref = $_[0];
	my $temp_in = $_[1];
	my $temp_out = $_[2];
	my $temp_exp = $_[3];
	my $temp_btp = $_[4];
	my $temp_out_gtf = $_[5];
	my $temp_out_exp = $_[6];
	my $temp_out_id = $_[7];
	my $random = `tr -dc A-Za-z0-9 </dev/urandom | head -c 10`;
	my %temp_strand_flag = ('+', 0, '-', 1);
	open(GTF, ">temp_$random.gtf") or die "Cannot create temp_$random.gtf!\n";
	print GTF "#perl NIAP_merge_v1.1.pl -i $temp_in -o $temp_out -exp $temp_exp -btp $temp_btp";
	if($temp_exp){
		open(EXP, ">$temp_out_exp") or die "Cannot create $temp_out_exp!\n";
		print EXP "Transcript";
		foreach my $temp_sample (@sample){
			print EXP "\t$temp_sample";
		}
	}
	open(ID, ">$temp_out_id") or die "Cannot create $temp_out_id!\n";
	print ID "Gene_id\tTranscript_id\tOriginal_id";
	foreach my $temp_chr (keys %{$loci_ref}){
		foreach my $temp_strand (keys %{$loci_ref->{$temp_chr}}){
			my $temp_loci_count = 1;
			foreach my $temp_loci (@{$loci_ref->{$temp_chr}{$temp_strand}}){
				#print "$temp_chr\t$temp_strand\t$temp_loci\n";
				print GTF "\n$temp_chr\tNIAP\tgene\t$temp_loci->[0]\t$temp_loci->[1]\t.\t$temp_strand\t.\tgene_id \"${temp_chr}_$temp_strand_flag{$temp_strand}_${temp_loci_count}\"\;";
				my @temp_loci = @{$temp_loci};
				my %temp_eej = %{$temp_loci[2]};
				my $temp_transcript_count = 1;
				foreach my $temp_eej (sort keys %temp_eej){
					foreach my $temp_transcript (@{$temp_eej{$temp_eej}}){
						my @temp_transcript = @{$temp_transcript};
						my $temp_eej_new = $temp_transcript[0]. $temp_eej . $temp_transcript[1];
						my @temp_eej = split(',', $temp_eej_new);
						my $temp_num_exon = @temp_eej;
						print GTF "\n$temp_chr\tNIAP\ttranscript\t$temp_transcript[0]\t$temp_transcript[1]\t.\t$temp_strand\t.\tgene_id \"${temp_chr}_$temp_strand_flag{$temp_strand}_${temp_loci_count}\"\; transcript_id \"${temp_chr}_$temp_strand_flag{$temp_strand}_${temp_loci_count}.${temp_transcript_count}\"\;";
						for(my $i = 0; $i < $temp_num_exon; $i++){
							my $temp_cur_exon_num;
							my @temp_exon = split('-', $temp_eej[$i]);
							#Handle exon number for record at the negative strand
							if($temp_strand eq "-"){
								$temp_cur_exon_num = $temp_num_exon - $i;
							}
							#Handle exon number for record at the positive and no strand
							else{
								$temp_cur_exon_num = $i + 1;
							}
							print GTF "\n$temp_chr\tStringTie\texon\t$temp_exon[0]\t$temp_exon[1]\t.\t$temp_strand\t.\tgene_id \"${temp_chr}_$temp_strand_flag{$temp_strand}_${temp_loci_count}\"\; transcript_id \"${temp_chr}_$temp_strand_flag{$temp_strand}_${temp_loci_count}.${temp_transcript_count}\"\; exon_number \"$temp_cur_exon_num\"\;";
						}
						if($temp_exp){
							print EXP "\n${temp_chr}_$temp_strand_flag{$temp_strand}_${temp_loci_count}.${temp_transcript_count}";
							foreach my $temp_exp (@{$temp_transcript[2]}){
								print EXP "\t$temp_exp";
							}
						}
						print ID "\n${temp_chr}_$temp_strand_flag{$temp_strand}_${temp_loci_count}\t${temp_chr}_$temp_strand_flag{$temp_strand}_${temp_loci_count}.${temp_transcript_count}\t";
						foreach my $temp_ref_id (keys %{$temp_transcript[3]}){
							print ID "$temp_ref_id,";
						}
						$temp_transcript_count++;
					}
				}
				$temp_loci_count++;
			}
		}
	}
	close GTF;
	if($temp_exp){
		close EXP;
	}
	close ID;
	
	system("bedtools sort -i temp_$random.gtf > $out_gtf");
	system("rm temp_$random.gtf");

	return 1;
}





